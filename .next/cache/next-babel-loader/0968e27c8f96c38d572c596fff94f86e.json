{"ast":null,"code":"export default function neuralnet(canvas) {\n  let w = canvas.width = 3 * window.innerWidth / 5;\n  let h = canvas.height = window.innerHeight;\n  const ctx = canvas.getContext('2d');\n  const opts = {\n    range: 180,\n    baseConnections: 3,\n    addedConnections: 5,\n    baseSize: 5,\n    minSize: 1,\n    dataToConnectionSize: 0.4,\n    sizeMultiplier: 0.7,\n    allowedDist: 40,\n    baseDist: 40,\n    addedDist: 30,\n    connectionAttempts: 60,\n    dataToConnections: 1,\n    baseSpeed: 0.04,\n    addedSpeed: 0.05,\n    baseGlowSpeed: 0.4,\n    addedGlowSpeed: 0.4,\n    rotVelX: 0.003,\n    rotVelY: 0.002,\n    repaintColor: '#202020',\n    connectionColor: 'hsla(200,60%,light%,alp)',\n    rootColor: 'hsla(0,60%,light%,alp)',\n    endColor: 'hsla(160,20%,light%,alp)',\n    dataColor: 'hsla(40,80%,light%,alp)',\n    wireframeWidth: 0.1,\n    wireframeColor: '#88f',\n    depth: 250,\n    focalLength: 250,\n    vanishPoint: {\n      x: w / 2,\n      y: h / 2\n    }\n  };\n  const squareRange = opts.range * opts.range;\n  const squareAllowed = opts.allowedDist * opts.allowedDist;\n  const mostDistant = opts.depth + opts.range;\n  let sinX = 0;\n  let sinY = 0;\n  let cosX = 0;\n  let cosY = 0;\n  const connections = [];\n  const toDevelop = [];\n  const data = [];\n  const all = [];\n  let tick = 0;\n  let animating = false;\n  const Tau = Math.PI * 2;\n  ctx.fillStyle = '#222';\n  ctx.fillRect(0, 0, w, h);\n  ctx.fillStyle = '#ccc';\n  ctx.font = '50px Verdana';\n  ctx.fillText('Calculating Nodes', w / 2 - ctx.measureText('Calculating Nodes').width / 2, h / 2 - 15);\n  window.setTimeout(init, 4); // to render the loading screen\n\n  function init() {\n    connections.length = 0;\n    data.length = 0;\n    all.length = 0;\n    toDevelop.length = 0;\n    var connection = new Connection(0, 0, 0, opts.baseSize);\n    connection.step = Connection.rootStep;\n    connections.push(connection);\n    all.push(connection);\n    connection.link();\n\n    while (toDevelop.length > 0) {\n      toDevelop[0].link();\n      toDevelop.shift();\n    }\n\n    if (!animating) {\n      animating = true;\n      anim();\n    }\n  }\n\n  function Connection(x, y, z, size) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.size = size;\n    this.screen = {};\n    this.links = [];\n    this.probabilities = [];\n    this.isEnd = false;\n    this.glowSpeed = opts.baseGlowSpeed + opts.addedGlowSpeed * Math.random();\n  }\n\n  Connection.prototype.link = function () {\n    if (this.size < opts.minSize) return this.isEnd = true;\n    var links = [],\n        connectionsNum = opts.baseConnections + Math.random() * opts.addedConnections | 0,\n        attempt = opts.connectionAttempts,\n        alpha,\n        beta,\n        len,\n        cosA,\n        sinA,\n        cosB,\n        sinB,\n        pos = {},\n        passedExisting,\n        passedBuffered;\n\n    while (links.length < connectionsNum && --attempt > 0) {\n      alpha = Math.random() * Math.PI;\n      beta = Math.random() * Tau;\n      len = opts.baseDist + opts.addedDist * Math.random();\n      cosA = Math.cos(alpha);\n      sinA = Math.sin(alpha);\n      cosB = Math.cos(beta);\n      sinB = Math.sin(beta);\n      pos.x = this.x + len * cosA * sinB;\n      pos.y = this.y + len * sinA * sinB;\n      pos.z = this.z + len * cosB;\n\n      if (pos.x * pos.x + pos.y * pos.y + pos.z * pos.z < squareRange) {\n        passedExisting = true;\n        passedBuffered = true;\n\n        for (var i = 0; i < connections.length; ++i) if (squareDist(pos, connections[i]) < squareAllowed) passedExisting = false;\n\n        if (passedExisting) for (var i = 0; i < links.length; ++i) if (squareDist(pos, links[i]) < squareAllowed) passedBuffered = false;\n        if (passedExisting && passedBuffered) links.push({\n          x: pos.x,\n          y: pos.y,\n          z: pos.z\n        });\n      }\n    }\n\n    if (links.length === 0) this.isEnd = true;else {\n      for (var i = 0; i < links.length; ++i) {\n        var pos = links[i],\n            connection = new Connection(pos.x, pos.y, pos.z, this.size * opts.sizeMultiplier);\n        this.links[i] = connection;\n        all.push(connection);\n        connections.push(connection);\n      }\n\n      for (var i = 0; i < this.links.length; ++i) toDevelop.push(this.links[i]);\n    }\n  };\n\n  Connection.prototype.step = function () {\n    this.setScreen();\n    this.screen.color = (this.isEnd ? opts.endColor : opts.connectionColor).replace('light', 30 + tick * this.glowSpeed % 30).replace('alp', 0.2 + (1 - this.screen.z / mostDistant) * 0.8);\n\n    for (var i = 0; i < this.links.length; ++i) {\n      ctx.moveTo(this.screen.x, this.screen.y);\n      ctx.lineTo(this.links[i].screen.x, this.links[i].screen.y);\n    }\n  };\n\n  Connection.rootStep = function () {\n    this.setScreen();\n    this.screen.color = opts.rootColor.replace('light', 30 + tick * this.glowSpeed % 30).replace('alp', (1 - this.screen.z / mostDistant) * 0.8);\n\n    for (var i = 0; i < this.links.length; ++i) {\n      ctx.moveTo(this.screen.x, this.screen.y);\n      ctx.lineTo(this.links[i].screen.x, this.links[i].screen.y);\n    }\n  };\n\n  Connection.prototype.draw = function () {\n    ctx.fillStyle = this.screen.color;\n    ctx.beginPath();\n    ctx.arc(this.screen.x, this.screen.y, this.screen.scale * this.size, 0, Tau);\n    ctx.fill();\n  };\n\n  function Data(connection) {\n    this.glowSpeed = opts.baseGlowSpeed + opts.addedGlowSpeed * Math.random();\n    this.speed = opts.baseSpeed + opts.addedSpeed * Math.random();\n    this.screen = {};\n    this.setConnection(connection);\n  }\n\n  Data.prototype.reset = function () {\n    this.setConnection(connections[0]);\n    this.ended = 2;\n  };\n\n  Data.prototype.step = function () {\n    this.proportion += this.speed;\n\n    if (this.proportion < 1) {\n      this.x = this.ox + this.dx * this.proportion;\n      this.y = this.oy + this.dy * this.proportion;\n      this.z = this.oz + this.dz * this.proportion;\n      this.size = (this.os + this.ds * this.proportion) * opts.dataToConnectionSize;\n    } else this.setConnection(this.nextConnection);\n\n    this.screen.lastX = this.screen.x;\n    this.screen.lastY = this.screen.y;\n    this.setScreen();\n    this.screen.color = opts.dataColor.replace('light', 40 + tick * this.glowSpeed % 50).replace('alp', 0.2 + (1 - this.screen.z / mostDistant) * 0.6);\n  };\n\n  Data.prototype.draw = function () {\n    if (this.ended) return --this.ended; // not sre why the thing lasts 2 frames, but it does\n\n    ctx.beginPath();\n    ctx.strokeStyle = this.screen.color;\n    ctx.lineWidth = this.size * this.screen.scale;\n    ctx.moveTo(this.screen.lastX, this.screen.lastY);\n    ctx.lineTo(this.screen.x, this.screen.y);\n    ctx.stroke();\n  };\n\n  Data.prototype.setConnection = function (connection) {\n    if (connection.isEnd) this.reset();else {\n      this.connection = connection;\n      this.nextConnection = connection.links[connection.links.length * Math.random() | 0];\n      this.ox = connection.x; // original coordinates\n\n      this.oy = connection.y;\n      this.oz = connection.z;\n      this.os = connection.size; // base size\n\n      this.nx = this.nextConnection.x; // new\n\n      this.ny = this.nextConnection.y;\n      this.nz = this.nextConnection.z;\n      this.ns = this.nextConnection.size;\n      this.dx = this.nx - this.ox; // delta\n\n      this.dy = this.ny - this.oy;\n      this.dz = this.nz - this.oz;\n      this.ds = this.ns - this.os;\n      this.proportion = 0;\n    }\n  };\n\n  Connection.prototype.setScreen = Data.prototype.setScreen = function () {\n    var x = this.x,\n        y = this.y,\n        z = this.z; // apply rotation on X axis\n\n    var Y = y;\n    y = y * cosX - z * sinX;\n    z = z * cosX + Y * sinX; // rot on Y\n\n    var Z = z;\n    z = z * cosY - x * sinY;\n    x = x * cosY + Z * sinY;\n    this.screen.z = z; // translate on Z\n\n    z += opts.depth;\n    this.screen.scale = opts.focalLength / z;\n    this.screen.x = opts.vanishPoint.x + x * this.screen.scale;\n    this.screen.y = opts.vanishPoint.y + y * this.screen.scale;\n  };\n\n  function squareDist(a, b) {\n    var x = b.x - a.x,\n        y = b.y - a.y,\n        z = b.z - a.z;\n    return x * x + y * y + z * z;\n  }\n\n  function anim() {\n    window.requestAnimationFrame(anim);\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.fillStyle = opts.repaintColor;\n    ctx.fillRect(0, 0, w, h);\n    ++tick;\n    var rotX = tick * opts.rotVelX,\n        rotY = tick * opts.rotVelY;\n    cosX = Math.cos(rotX);\n    sinX = Math.sin(rotX);\n    cosY = Math.cos(rotY);\n    sinY = Math.sin(rotY);\n\n    if (data.length < connections.length * opts.dataToConnections) {\n      var datum = new Data(connections[0]);\n      data.push(datum);\n      all.push(datum);\n    }\n\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.beginPath();\n    ctx.lineWidth = opts.wireframeWidth;\n    ctx.strokeStyle = opts.wireframeColor;\n    all.map(function (item) {\n      item.step();\n    });\n    ctx.stroke();\n    ctx.globalCompositeOperation = 'source-over';\n    all.sort(function (a, b) {\n      return b.screen.z - a.screen.z;\n    });\n    all.map(function (item) {\n      item.draw();\n    });\n  }\n\n  window.addEventListener('resize', function () {\n    opts.vanishPoint.x = (w = canvas.width = 4 * window.innerWidth / 5) / 2;\n    opts.vanishPoint.y = (h = canvas.height = window.innerHeight) / 2;\n    ctx.fillRect(0, 0, w, h);\n  }); //   window.addEventListener('click', init);\n}","map":null,"metadata":{},"sourceType":"module"}